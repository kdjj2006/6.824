6.824 2017 Lecture 10: FaRM
* 课程注意：最终项目提案本周五到期！
    * 可以做最终项目或者实验4
    * 组成2-3个学生的小组
    * 请跟我们讨论/email 关于项目的想法
* 我们为什么读这篇论文？
    * 很多人希望分布式事务
    * 但被认为很慢
    * 这篇论文认为那样不正确 -- 非常惊人的性能
* 大的性能图
    * 9千万 “复制” “持久化” “事务” 每秒(图7)
        * 1百万事务/秒 每台机器
        * 每个有一些消息，用来复制和提交
        * 很优秀
    * 一些其他的系统获得了1百万操作/秒 每台机器，例如 memcached
        * 但不是事务 + 复制 + 持久化(通常不是这些)
    * 9千万的透视
        * 每秒 10,000 Tweets
        * 每秒 2,000,000 邮件
* 他们如何获得高性能
    * 数据必须全部 RAM 中(因此没有磁盘读)
    * 非易失性RAM (因此没有磁盘写)
    * 单面 RDMA(快速跨网络访问 RAM)
    * 快速用户级访问 NIC
    * 利用单面RDMA 的事务 + 复制协议
* NVRAM
    * FaRM 写入 RAM，不是磁盘 -- 消除了巨大的瓶颈
    * 可以在 200 ns 写 RAM，但要花费 10 ms 写磁盘，SSD 100 us
      *  ns = nanosecond, ms = millisecond, us = microsecond
    * 但 RAM 在电源故障时失去数据，本身并持久化
    * 为什么不仅仅写入 f+1 个机器的 RAM，来容忍 f 个故障
        * 如果故障通常是独立的可能足够了
        * 但是电源故障不是独立的 -- 可能影响所有机器
    * 因此
        * 每个机架都有电源，可以运行机器几分钟
        * 电源硬件当主电源故障通知软件
        * 软件暂停所有进行中的事物
        * 软件将 FaRM 的 RAM 写入 SSD，可能花费几分钟
        * 然后机器关机
        * 当重启的时候，FaRM 从 SSD 读入保存的内存镜像
        * "非易失性RAM"
    * 如果故障阻止软件写 SSD 怎么办
        * 例如 FaRM 或者 kernel 的 bug，或者 cpu/memory/hardware 出错了
        * FaRM 应对单机故障通过拷贝数据
            * 从机器副本的 RAM 拷贝到其他机器
            * 保证一直有 f+1 份拷贝
        * 故障(电源故障除外)必须是独立的
* 为什么网络经常是一个性能瓶颈？
    * 通常配置
    ```java
       app                     app
       ---                     ---
       socket buffers          buffers
       TCP                     TCP
       NIC driver              driver
       NIC  ------------------ NIC
    ```

    * 很多昂贵的 CPU 操作
        * 系统调用
        * 拷贝消息
        * 中断
        * 如果 RPC 调用两次
    * 慢
        * 很难构建能发送超过 100,000/秒的 RPC
        * 这些每个数据包 CPU 成本是小消息的限制因素
* 内核旁路
    * 应用访问 NIC 硬件是流线型的
    * 应用直接和 NIC 交互 -- 没有系统调用，没有内核
    * 应用和 NIC 之间的共享内存映射
    * 发送者给 NIC 一个 RDMA 命令
    * 对于 RPC，接收者软件轮训 DRMA 写入的内存
* FaRM 的网络设置
    * NIC 使用 "单边 RDMA"：内存读/写，不是数据包传递
    * 发送者说"将这些数据写入此地址"，或者"读此地址"
        * NIC 硬件在远端执行
        * 返回一个"硬件确认"
    * 在远端没有没有中断，内核，拷贝，读
    * 一台服务器的吞吐量：1千万+/秒(图2)
    * 延迟：5 微妙(从他们2014年 NSDI 论文)
    * FaRM以三种方式使用RDMA：
        * 在事务执行期间的对象单边读(包括验证)
        * RPC由单向主要日志的写入或消息队列组成
        * 单边写入副本日志
* 大挑战：
    * 如何对事务和副本使用单边读/写
    * 我们看到的协议要求接收器 CPU 主动处理消息
        * 例如 Raft 和两阶段提交
* 让我们复习下分布式事务
* 记住本例子：
    * x 和 y 是银行余额，可能位于不同服务器上
    * ```java
         T1:             T2:
        add(x, 1)       tmp1 = get(x)
        add(y, -1)      tmp2 = get(y)
                        print tmp1, tmp2
    * x 和 y 开始都是 $10
    * 我们希望串行化    
        * 结果应该好像事务按某种顺序一次运行一个
    * 只可能两种顺序是可能的
        * T1 然后 T2，产生 11,9
        * T2 然后 T1，产生 10,10
        * 串行化不允许其他结果
* 如果 T1 全部在 T2 的两个 get() 中间执行怎么样？
    * 如果事务协议允许会打印 10,9
    * 但不允许
* 如果 T2 全部在 T1 的两个 add() 中间执行怎么样？
    * 如果事务协议允许会打印 11,10
    * 但不允许 
* 事务的两类并发控制
    * 悲观
        * 等待第一次使用对象时锁定; 一直持有到提交/中止
        * 成为两阶段锁定
        * 冲突会导致延迟
    * 乐观
        * 访问对象是没有所以，提交"验证"来看是不是可以
            * 合法：执行写入
            * 非法： 退出
        * 称为乐观并发控制(OCC)
* FaRM 使用 OCC
    * 原因：OCC 允许 FaRM 使用单边 RDMA 读取进行读取
        * 由于 OCC，服务器存对象无需设置锁
    * FaRM 如何验证？我们稍后看图4
