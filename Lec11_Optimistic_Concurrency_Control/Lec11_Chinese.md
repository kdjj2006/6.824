6.824 2017 Lecture 10: FaRM
* 课程注意：最终项目提案本周五到期！
    * 可以做最终项目或者实验4
    * 组成2-3个学生的小组
    * 请跟我们讨论/email 关于项目的想法
* 我们为什么读这篇论文？
    * 很多人希望分布式事务
    * 但被认为很慢
    * 这篇论文认为那样不正确 -- 非常惊人的性能
* 大的性能图
    * 9千万 “复制” “持久化” “事务” 每秒(图7)
        * 1百万事务/秒 每台机器
        * 每个有一些消息，用来复制和提交
        * 很优秀
    * 一些其他的系统获得了1百万操作/秒 每台机器，例如 memcached
        * 但不是事务 + 复制 + 持久化(通常不是这些)
    * 9千万的透视
        * 每秒 10,000 Tweets
        * 每秒 2,000,000 邮件
* 他们如何获得高性能
    * 数据必须全部 RAM 中(因此没有磁盘读)
    * 非易失性RAM (因此没有磁盘写)
    * 单面 RDMA(快速跨网络访问 RAM)
    * 快速用户级访问 NIC
    * 利用单面RDMA 的事务 + 复制协议
* NVRAM
    * FaRM 写入 RAM，不是磁盘 -- 消除了巨大的瓶颈
    * 可以在 200 ns 写 RAM，但要花费 10 ms 写磁盘，SSD 100 us
      *  ns = nanosecond, ms = millisecond, us = microsecond
    * 但 RAM 在电源故障时失去数据，本身并持久化
    * 为什么不仅仅写入 f+1 个机器的 RAM，来容忍 f 个故障
        * 如果故障通常是独立的可能足够了
        * 但是电源故障不是独立的 -- 可能影响所有机器
    * 因此
        * 每个机架都有电源，可以运行机器几分钟
        * 电源硬件当主电源故障通知软件
        * 软件暂停所有进行中的事物
        * 软件将 FaRM 的 RAM 写入 SSD，可能花费几分钟
        * 然后机器关机
        * 当重启的时候，FaRM 从 SSD 读入保存的内存镜像
        * "非易失性RAM"
    * 如果故障阻止软件写 SSD 怎么办
        * 例如 FaRM 或者 kernel 的 bug，或者 cpu/memory/hardware 出错了
        * FaRM 应对单机故障通过拷贝数据
            * 从机器副本的 RAM 拷贝到其他机器
            * 保证一直有 f+1 份拷贝
        * 故障(电源故障除外)必须是独立的
* 为什么网络经常是一个性能瓶颈？
    * 通常配置
    ```java
       app                     app
       ---                     ---
       socket buffers          buffers
       TCP                     TCP
       NIC driver              driver
       NIC  ------------------ NIC
    ```

    * 很多昂贵的 CPU 操作
        * 系统调用
        * 拷贝消息
        * 中断
        * 如果 RPC 调用两次
    * 慢
        * 很难构建能发送超过 100,000/秒的 RPC
        * 这些每个数据包 CPU 成本是小消息的限制因素
* 内核旁路
    * 应用访问 NIC 硬件是流线型的
    * 应用直接和 NIC 交互 -- 没有系统调用，没有内核
    * 应用和 NIC 之间的共享内存映射
    * 发送者给 NIC 一个 RDMA 命令
    * 对于 RPC，接收者软件轮训 DRMA 写入的内存