6.824 2017 Lecture 10: FaRM
* 课程注意：最终项目提案本周五到期！
    * 可以做最终项目或者实验4
    * 组成2-3个学生的小组
    * 请跟我们讨论/email 关于项目的想法
* 我们为什么读这篇论文？
    * 很多人希望分布式事务
    * 但被认为很慢
    * 这篇论文认为那样不正确 -- 非常惊人的性能
* 大的性能图
    * 9千万 “复制” “持久化” “事务” 每秒(图7)
        * 1百万事务/秒 每台机器
        * 每个有一些消息，用来复制和提交
        * 很优秀
    * 一些其他的系统获得了1百万操作/秒 每台机器，例如 memcached
        * 但不是事务 + 复制 + 持久化(通常不是这些)
    * 9千万的透视
        * 每秒 10,000 Tweets
        * 每秒 2,000,000 邮件
* 他们如何获得高性能
    * 数据必须全部 RAM 中(因此没有磁盘读)
    * 非易失性RAM (因此没有磁盘写)
    * 单面 RDMA(快速跨网络访问 RAM)
    * 快速用户级访问 NIC
    * 利用单面RDMA 的事务 + 复制协议
* NVRAM
    * FaRM 写入 RAM，不是磁盘 -- 消除了巨大的瓶颈
    * 可以在 200 ns 写 RAM，但要花费 10 ms 写磁盘，SSD 100 us
      *  ns = nanosecond, ms = millisecond, us = microsecond
    * 但 RAM 在电源故障时失去数据，本身并持久化
    * 为什么不仅仅写入 f+1 个机器的 RAM，来容忍 f 个故障
        * 如果故障通常是独立的可能足够了
        * 但是电源故障不是独立的 -- 可能影响所有机器
    * 因此
        * 每个机架都有电源，可以运行机器几分钟
        * 电源硬件当主电源故障通知软件
        * 软件暂停所有进行中的事物
        * 软件将 FaRM 的 RAM 写入 SSD，可能花费几分钟
        * 然后机器关机
        * 当重启的时候，FaRM 从 SSD 读入保存的内存镜像
        * "非易失性RAM"
    * 如果故障阻止软件写 SSD 怎么办
        * 例如 FaRM 或者 kernel 的 bug，或者 cpu/memory/hardware 出错了
        * FaRM 应对单机故障通过拷贝数据
            * 从机器副本的 RAM 拷贝到其他机器
            * 保证一直有 f+1 份拷贝
        * 故障(电源故障除外)必须是独立的
* 为什么网络经常是一个性能瓶颈？
    * 通常配置
    ```java
       app                     app
       ---                     ---
       socket buffers          buffers
       TCP                     TCP
       NIC driver              driver
       NIC  ------------------ NIC
    ```

    * 很多昂贵的 CPU 操作
        * 系统调用
        * 拷贝消息
        * 中断
        * 如果 RPC 调用两次
    * 慢
        * 很难构建能发送超过 100,000/秒的 RPC
        * 这些每个数据包 CPU 成本是小消息的限制因素
* 内核旁路
    * 应用访问 NIC 硬件是流线型的
    * 应用直接和 NIC 交互 -- 没有系统调用，没有内核
    * 应用和 NIC 之间的共享内存映射
    * 发送者给 NIC 一个 RDMA 命令
    * 对于 RPC，接收者软件轮训 DRMA 写入的内存
* FaRM 的网络设置
    * NIC 使用 "单边 RDMA"：内存读/写，不是数据包传递
    * 发送者说"将这些数据写入此地址"，或者"读此地址"
        * NIC 硬件在远端执行
        * 返回一个"硬件确认"
    * 在远端没有没有中断，内核，拷贝，读
    * 一台服务器的吞吐量：1千万+/秒(图2)
    * 延迟：5 微妙(从他们2014年 NSDI 论文)
    * FaRM以三种方式使用RDMA：
        * 在事务执行期间的对象单边读(包括验证)
        * RPC由单向主要日志的写入或消息队列组成
        * 单边写入副本日志
* 大挑战：
    * 如何对事务和副本使用单边读/写
    * 我们看到的协议要求接收器 CPU 主动处理消息
        * 例如 Raft 和两阶段提交
* 让我们复习下分布式事务
* 记住本例子：
    * x 和 y 是银行余额，可能位于不同服务器上
    * ```java
         T1:             T2:
        add(x, 1)       tmp1 = get(x)
        add(y, -1)      tmp2 = get(y)
                        print tmp1, tmp2
    * x 和 y 开始都是 $10
    * 我们希望串行化    
        * 结果应该好像事务按某种顺序一次运行一个
    * 只可能两种顺序是可能的
        * T1 然后 T2，产生 11,9
        * T2 然后 T1，产生 10,10
        * 串行化不允许其他结果
* 如果 T1 全部在 T2 的两个 get() 中间执行怎么样？
    * 如果事务协议允许会打印 10,9
    * 但不允许
* 如果 T2 全部在 T1 的两个 add() 中间执行怎么样？
    * 如果事务协议允许会打印 11,10
    * 但不允许 
* 事务的两类并发控制
    * 悲观
        * 等待第一次使用对象时锁定; 一直持有到提交/中止
        * 成为两阶段锁定
        * 冲突会导致延迟
    * 乐观
        * 访问对象是没有所以，提交"验证"来看是不是可以
            * 合法：执行写入
            * 非法：退出
        * 称为乐观并发控制(OCC)
* FaRM 使用 OCC
    * 原因：OCC 允许 FaRM 使用单边 RDMA 读取进行读取
        * 由于 OCC，服务器存对象无需设置锁
    * FaRM 如何验证？我们稍后看图4
* 每个 FaRM 服务器都运行应用事务并存储对象
    * 一个应用事务在它自己的事务协调器上(TC)
* FaRM 事务 API(简化的)
    * ```java
      txCreate()
      o = txRead(oid)  -- RDMA
      o.f += 1
      txWrite(oid, o)  -- purely local
      ok = txCommit()  -- Figure 4
* txRead
    * 单边 RDMA 来直接从主存获取对象 -- 快
    * 也抓取对象的版本号，来检测并发写
* txWrite
    * 必须在 txRead 之前
    * 只写入本地拷贝，没有通信
* 什么是一个 oid?
    * <region #, address>
    * 区域(region) 索引映射到[主，备1，...]
    * 目标 NIC 可以使用地址(address) 直接从 RAM 读或写入
        * 索引目标 CPU 不需要参与
* 服务器内存分步
    * 区域(region)，每个对象数组
    * 对象分步
        * 具有版本号和锁的标头
    * 对每个其他的服务器
        * 由 RDMA 编写，通过轮询读取
        * 传入的日志
        * 传入的消息队列
    * 所有这些都在非易失性的 RAM 中(即停电时写入 SSD)
* 每个区域都在一个主，f个备份上复制 -- f+1 个副本
    * 只有主服务器读；所有 f+1 个服务器可看见提交和写
    * 如果<= f 个失败，复制将产生可用性(仍然可用)
        * 只要一个副本还可用就可用，比 Raft 好
* 事务执行/无故障的提交协议 -- 图4
    * 让我们一个一个考虑图4中的步骤
    * 现在就考虑并发控制（不是复制）
* LOCK(提交协议的一个消息)
    * TC 为每个写对象发给主服务器
    * TC 使用 RDMA 来在每个主服务器上追加日志
    * LOCK 记录考虑 oid,版本号 # xaction 读，新值
    * 主服务器轮询日志，检查 LOCK,验证，发送 "yes" 或者 "no" 的回复消息
    * 注意 LOCK 在主服务器的 NVRAM 和 RPC 交互中都有记录
* TC 等待所有 LOCK 返回消息
    * 如果有任何人返回的是"no",终止
        * 发送 ABORT 给主机然后他们释放锁
        * 从 txCommit() 返回 "no"
* 让我们现在忽略 VALIDATE 和 COMMIT BACKUP
* TC 为每个写入对象发送 COMMIT-PRIMARY 给主服务器
    * 使用 RDMA 来追加主服务器的日志
    * TC 只等待硬件 ack -- 不等待主服务器执行日志追加
    * TC 从 txCommit() 返回 "yes"
* 当主服务器在日志上执行 COMMIT-PRIMARY 的时候回做什么？
    * 将新值复制到对象的内存中
    * 增加对象版本号
    * 清除对象锁标记
* 例子：
    * T1 和 T2 都想增加 x
    * 都说
        ```java
        tmp = txRead(x)
        tmp += 1
        txWrite(x)
        ok = txCommit()
    * x 应该以0，1或者2结尾，与成功提交的数量一致
* 如果 T1 和 T2 完全操作一致会怎么样
    * ```java
        T1: Rx0  Lx  Cx
    * ```java
        T2: Rx0  Lx  Cx
    * 会发生什么？
* 或者 
    * ```java
        T1:    Rx0 Lx Cx
    * ```java
        T2: Rx0          Lx  Cx
* 或者
    * ```java
        T1: Rx0  Lx  Cx
    * ```java
        T2:             Rx0  Lx  Cx
* 验证为什么检查可序列化性的直觉：
    * 检查“是一次执行一个”
    * 如果没有冲突，版本不会变，允许提交
    * 如果有冲突，一个会发现锁或者改变版本号
* 关于图4中的 VALIDATE
    * 它是对事务刚刚读取的对象的优化
    * VALIDATE = 获取对象版本和锁标记的单边 RDMA 读
    * 如果设置了锁，或者读取后版本改变了，TC 中止
    * 没有设置锁，因此比 LOCK + COMMIT 快
* VALIDATE 例子：
    * x 和 y 初始化都是0
    * T1
        ```java
        if x == 0:
            y = 1
    * T2
        ```java
        if y == 0:
            x = 1
    * 这是一个经典的一致性测试案例
    * T1,T2 生成 y=1,x=0
    * T2,T1 生成 x=1,y=0
    * 中止可能会是 x=0,y=0
    * 但串行化禁止生成 x=1,y=1
* 假设同时执行
    * ```java
        T1:  Rx  Ly  Vx  Cy
        T2:  Ry  Lx  Vy  Cx
    * LOCKs 操作都成功
    * VALIDATEs 会都失败，因为锁标记位都被设置了
    * 所有都会中止 -- 这是可以的
* 或者
    * ```java
        T1:  Rx  Ly  Vx      Cy
        T2:  Ry          Lx  Vy  Cx
    * 然后 T1 提交，T2 仍会中止因为 T2 的 Vy 发现 T1 的锁或者更高的版本号
    * 所以 VALIDATE 在这个例子中看起来是对的
        * 并且快：比 LOCK 快，不需要 COMMIT 
* 容错呢？
    * 防止数据丢失？
        * 持久？可用？
    * 即使崩溃，保证进行中的交易的完整性
    * 分区？
* 高层次复制图
    * ```java
        o o region 1
        o o region 2
        o CM
        o o o ZK
* 