第16课: Scaling Memcache at Facebook
* 我们为什么读这篇论文
    * 是关于经验的论文，没有什么新思想/技术
    * 三种阅读方式
        * 不认真一致性问题的警惕性故事
        * 从现成的 S/W 看超高容量的令人印象深刻的故事
        * 性能与一致性之间的根本斗争
    * 我们可以争论他们的设计，但不是他们的成功
* 网站如何随着负载的增加而扩展？
    * 随时间演变的典型故事：
    * 1.单机器，web 服务器，应用，数据库
        * 数据库存储在磁盘上，崩溃回复，事务，SQL
        * 应用查询数据库，格式化，HTML
        * 但是负载增长，你的 PHP 应用需要太多的 CPU 时间
    * 2.许多 web 前端，一个共享的数据库
        * 一个简单的变化，web 服务器和 app 已经分开存储
        * 前端无状态，所有共享(和并发控制)通过数据库
        * 但是负载增长，增加更多的前端，很快单数据库服务器变成瓶颈
    * 3.许多 web 前端，数据库通过数据库集群共享
        * 数据库通过 key 分区数据
            * app 查看 key(例如用户)，决定正确的数据库 
        * 如果没有数据太受欢迎(注：热门数据)会有很好的数据库并行性
        * 痛楚 -- 跨分区的事务和查询可能不生效
            * 很难划分得太细
        * 但是数据库很慢，即使读，为什么不缓存读请求呢？
    * 4.许多 web 前端，很多读缓存，很多写库
        * 具有成本效益的大量读取和 memcached 比数据库快10倍
            * memcached 只是一个内存哈希表，很简单
        * 复杂的数据库和 memcacheds 可能不同步
        * 下个瓶颈就是数据库写 -- 很难解决