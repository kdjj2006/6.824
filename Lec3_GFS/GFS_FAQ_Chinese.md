GFS FAQ
*** 
* 问题：为什么原子性记录追加至少一次，而不是正好一次？
    * 回答：很难让追加正好一次，因为主 chunk 服务器需要保持状态来进行重复检测。状态必须在服务器之间复制，如果主 chunk 服务器宕机了，信息不会丢失。你在实验3中要实现正好一次，但是使用了比 GFS 复杂的多的协议。
* 问题：应用程序如何知道块的哪部分包含填充(注：块不满64M 部分进行填充)和重复记录？
    * 回答：为了检测填充，应用可以在一个有效记录的开始加上一个可预测的魔数，或者包含一个只可能在记录有效时才有效的 checksum。应用可以检测重复通过在记录中包含唯一的 ID。然后，如果读一个和前记录有相同 ID 的记录，它知道它们相互重复。GFS 提供了一个来处理这些案例的库。
* 问题：如果原子记录追加，客户端如何找到它们的数据将其写入文件中不可预测的偏移量
    * 回答：追加(而且 GFS 一般也是)主要是用于应用读取整个文件。这些应用会查找每条记录(详见上一问题)，所以它们不需要提前知道记录的地址。例如，文件可能包含一系列由一组并发 WEB 爬虫遇到的链接 URL。这个关于任何给定的 URL 的文件偏移量并不重要，读者只希望能够读取到整个 URL 集合。
* 问题：论文中提到了引用计数 -- 这是什么？
    * 回答：它们是快照 copy-on-write 实现的一部分。当 GFS 新建快照，它并不复制块，而是增加每个块的引用计数值。这就让新建快照低成本。如果一个客户端写入一个块，而且 master 注意到引用计数大于1，master 首先新建一份副本，客户端可以更新这个副本(而不是作为快照一部分的块)。你可以把这个看成是复制推迟，直到绝对需要。希望就是不是所有的块都被修改而且可以避免新建一些副本。
* 问题：如果一个应用使用标准的 POSIX 文件系统 API,那它是否需要做一些修改从而可以使用 GFS 呢？
    * 回答：是的，但是 GFS 不是为现有系统设计的。它是为新编写的应用设计的，例如 MapReduce 程序。
* 问题：GFS 如何确定最近副本的位置？
    * 回答：论文提示说 GFS 基于存储可用副本的服务器的 IP 地址实现的。在2003年，Google肯定是以这样的方式分配IP地址：如果两个 IP 地址在 IP 地址空间中彼此靠近，那么它们在机房中也靠近。
* 问题：Google 还在用 GFS 吗？
    * 回答：GFS 还在使用并且它还是其他存储系统例如 BigTable 的后台。GFS 的设计多年来肯定已经调整过，因为工作量越来越大，技术也在变化，但我不知道细节。HDFS 是公共领域克隆了 GFS 的设计，很多公司都在用。
* 问题：master 会不会成为性能瓶颈？
    * 回答：肯定有那个潜在问题，而且 GFS 的设计者在避免这个问题而烦恼。例如，master 在内存中保存状态就可以回复很迅速。这个对于大文件/读(GFS的工作目标)，master 不是瓶颈。对于小文件的操作或者目录操作，master 可以胜任(详见论文6.2.4章节)。
* 问题：GFS 为了性能的交易正确性和简单性多少可以接受？
    * 回答：这是分布式系统永恒的主题。强一致性通常需要复杂的协议并且需要在机器间的闲聊通信(就跟我们下节课要看到的那样)。通过利用特定应用程序类可以容忍松一致性的方式，一个人可以设计出高性能和足够一致性的系统。例如，GFS 优化 MapReduce 应用，就需要对大文件很好的读性能并且在文件有漏洞，记录出现几次，不一致的读也 OK。另一方面，GFS 对于存储银行账户余额就不好了。
* 问题：如果 master 宕机了怎么办？
    * 回答：这存在具有 master 状态的完整副本的副本 master；如果当前 master 宕机，一个未知机制切换到一个副本(5.1.3章节)。也可以人为干预指定新 master。无论如何，几乎可以肯定的是潜伏在这里的单点故障在理论上可以阻止从主故障中自动恢复。我们会在下节课学习你如何使用 Raft 构建一个容错的 master。