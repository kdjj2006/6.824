6.824 2018 第4课：主备复制

* 今天 
    * 容错的主备复制
    * VMware FT 案例学习，这个思想的极端案例
* 容错
    * 我们希望一个服务尽管有失败但仍继续运行
    * 一些理想的属性：
        * 可用：尽管有失败仍然可以用
        * 强一致性：对客户端来说看着像一台服务器
        * 对客户透明
        * 对服务端软件透明
        * 高效  
* 哪些故障是我们尝试去解决的？
    * 故障停机错误
    * 独立故障
    * 网络丢弃部分/全部数据包
    * 网络分区
* 但不是：
    * 不正确的执行
    * 相关的错误
    * 配置错误
    * 恶意错误
* 行为
    * 可用，例如一台服务器宕机
    * 等待，例如网络全部失败
    * 永远停机，例如很多服务器宕机
    * 故障，如果 h/w 计算错误，或者软件有 bug
* 关键思想：复制
    * 两台服务器，或者更多
    * 每个副本保存服务需要的状态
    * 如果一个副本失败，其他可以继续
* 例子：容错的 MapReduce master
    * 实验1 的 worker 已经容错了，但 master 没有
        * master 是一个“单点故障”
    * 我们能不能用两个 master,如果一个失败了？
    * 状态:
        * worker 列表
        * 哪些任务完成了
        * 哪些 worker 空闲
        * TCP 连接状态
        * 程序内存和栈
        * CPU 寄存器
* 重大问题:
    * 复制哪些状态？
    * 主机要不要等待备机？
    * 什么时候切换到备机？
    * 在切换的时候是否异常可见？
    * 如何提高备机速度？
* 两个主要方法：
    * 状态转移
        * 主副本执行服务
        * 主副本发送[新]状态给备机
    * 复制状态机
        * 所有的副本执行所有操作
        * 如果有相同的开始状态，相同的操作，相同的顺序，确定性
            * 就有相同的结束状态
* 状态转移更简单
    * 但状态可能很巨大，转移慢
    * VM-FT 使用了复制状态机
* 复制状态机更高效
    * 如果操作相对于数据较小
    * 但要正确很难
    * 实验 2/3/4 使用复制状态机
* 在什么层级定义状态复制机？
    * Key/Value 的 put 和 get？
        * 应用层 RSM
        * 通常需要服务端和客户端修改
        * 可以高效；主机只发送高级别的操作给备份机
    * X86 指令？
        * 可能允许我们复制任何 w/o 修改的现有服务器
        * 但是需要更多详细的主备同步
        * 而且我们需要应付中断，DMA，奇怪的 X86 指令
#### 本课论文
* The design of a Practical System for Fault-Tolerant Virtual Machines  
Scales, Nelson, and Venkitachalam, SIGOPS OSR Vol 44, No 4, Dec 2010    
注：课程论文
* 很不凡的系统：
    * 目标：对享有的服务器软件容错
    * 目标：客户端可以感知故障
    * 目标：客户端和服务器软件不需要修改
    *  很有雄心壮志
* 概要
    * 关键词
        * hypervisor == monitor == VMM (virtual machine monitor)
        * 应用和 O/S 是运行在虚拟机内部的“客户”
    * 两台机器，主机和备机
    * 共享磁盘用来持久化存储
        * 共享然后启动新备机更快
    * 主机通过日志通道发送所有输入给备机
* 这个想法为什么能生效？
    * 这是个备份状态机
    * 主机和备机以相同初始化状态启动(内存，磁盘文件)
    * 相同指令，相同输入 -> 相同的执行
        * 在其他条件相同的情况下，主机和备机保持一致
* 我们必须防范哪些差异来源？
    * 很多指令来保证在主机和备机上执行完全一致
        * 只要内存和寄存器一致，我们通过归纳假设
    * 什么时候主机上的执行和备机上的可能不一样？
    * 外界的输入(网络)
    * 从存储服务器读的数据
    * 定时中断
    * 指令不是纯粹的状态函数，例如循环计数器
    * 竞态
* 差异的例子？
    * 它们都听起来像“如果主机宕机了，客户端会从备机中看到不一样的故事”
    * 锁服务器授予客户端 C1 锁，拒绝后续来自 C2 的请求
        * 主备在输入顺序上有更好的商定
        * 否则，主机宕机了，备机告诉客户端 C2 持有锁
    * 锁服务器一分钟只会撤销锁
        * 假设 C1 持有锁，时间几乎用完
        * C2 请求锁
        * 主机可能恰好在计时器中断之前看到 C2 的请求，拒绝
        * 备机可能恰好在计时器中断之后看到 C2 的请求，授权
    * 所以：备机必须看到相同事件，按照相同顺序，在指令流中的同一点