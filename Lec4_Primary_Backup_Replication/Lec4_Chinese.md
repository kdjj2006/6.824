6.824 2018 第4课：主备复制

* 今天 
    * 容错的主备复制
    * VMware FT 案例学习，这个思想的极端案例
* 容错
    * 我们希望一个服务尽管有失败但仍继续运行
    * 一些理想的属性：
        * 可用：尽管有失败仍然可以用
        * 强一致性：对客户端来说看着像一台服务器
        * 对客户透明
        * 对服务端软件透明
        * 高效  
* 哪些故障是我们尝试去解决的？
    * 故障停机错误
    * 独立故障
    * 网络丢弃部分/全部数据包
    * 网络分区
* 但不是：
    * 不正确的执行
    * 相关的错误
    * 配置错误
    * 恶意错误
* 行为
    * 可用，例如一台服务器宕机
    * 等待，例如网络全部失败
    * 永远停机，例如很多服务器宕机
    * 故障，如果 h/w 计算错误，或者软件有 bug
* 关键思想：复制
    * 两台服务器，或者更多
    * 每个副本保存服务需要的状态
    * 如果一个副本失败，其他可以继续
* 例子：容错的 MapReduce master
    * 实验1 的 worker 已经容错了，但 master 没有
        * master 是一个“单点故障”
    * 我们能不能用两个 master,如果一个失败了？
    * 状态:
        * worker 列表
        * 哪些任务完成了
        * 哪些 worker 空闲
        * TCP 连接状态
        * 程序内存和栈
        * CPU 寄存器
* 重大问题:
    * 复制哪些状态？
    * 主机要不要等待备机？
    * 什么时候切换到备机？
    * 在切换的时候是否异常可见？
    * 如何提高备机速度？
* 两个主要方法：
    * 状态转移
        * 主副本执行服务
        * 主副本发送[新]状态给备机
    * 复制状态机
        * 所有的副本执行所有操作
        * 如果有相同的开始状态，相同的操作，相同的顺序，确定性
            * 就有相同的结束状态
* 状态转移更简单
    * 但状态可能很巨大，转移慢
    * VM-FT 使用了复制状态机
* 复制状态机更高效
    * 如果操作相对于数据较小
    * 但要正确很难
    * 实验 2/3/4 使用复制状态机
* 在什么层级定义状态复制机？
    * Key/Value 的 put 和 get？
        * 应用层 RSM
        * 通常需要服务端和客户端修改
        * 可以高效；主机只发送高级别的操作给备份机
    * X86 指令？
        * 可能允许我们复制任何 w/o 修改的现有服务器
        * 但是需要更多详细的主备同步
        * 而且我们需要应付中断，DMA，奇怪的 X86 指令
* 论文
    * The design of a Practical System for Fault-Tolerant Virtual Machines  
Scales, Nelson, and Venkitachalam, SIGOPS OSR Vol 44, No 4, Dec 2010    
   注：课程论文
    * 很不凡的系统：
        * 目标：对享有的服务器软件容错
        * 目标：客户端可以感知故障
        * 目标：客户端和服务器软件不需要修改
        *  很有雄心壮志
