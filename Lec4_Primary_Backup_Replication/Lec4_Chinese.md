6.824 2018 第4课：主备复制

* 今天 
    * 容错的主备复制
    * VMware FT 案例学习，这个思想的极端案例
* 容错
    * 我们希望一个服务尽管有失败但仍继续运行
    * 一些理想的属性：
        * 可用：尽管有失败仍然可以用
        * 强一致性：对客户端来说看着像一台服务器
        * 对客户透明
        * 对服务端软件透明
        * 高效  
* 哪些故障是我们尝试去解决的？
    * 故障停机错误
    * 独立故障
    * 网络丢弃部分/全部数据包
    * 网络分区
* 但不是：
    * 不正确的执行
    * 相关的错误
    * 配置错误
    * 恶意错误
* 行为
    * 可用，例如一台服务器宕机
    * 等待，例如网络全部失败
    * 永远停机，例如很多服务器宕机
    * 故障，如果硬件计算错误，或者软件有 bug
* 关键思想：复制
    * 两台服务器，或者更多
    * 每个副本保存服务需要的状态
    * 如果一个副本失败，其他可以继续
* 例子：容错的 MapReduce master
    * 实验1 的 worker 已经容错了，但 master 没有
        * master 是一个“单点故障”
    * 我们能不能用两个 master,如果一个失败了？
    * 状态:
        * worker 列表
        * 哪些任务完成了
        * 哪些 worker 空闲
        * TCP 连接状态
        * 程序内存和栈
        * CPU 寄存器
* 重大问题:
    * 复制哪些状态？
    * 主机要不要等待备机？
    * 什么时候切换到备机？
    * 在切换的时候是否异常可见？
    * 如何提高备机速度？
* 两个主要方法：
    * 状态转移
        * 主副本执行服务
        * 主副本发送[新]状态给备机
    * 复制状态机
        * 所有的副本执行所有操作
        * 如果有相同的开始状态，相同的操作，相同的顺序，确定性
            * 就有相同的结束状态
* 状态转移更简单
    * 但状态可能很巨大，转移慢
    * VM-FT 使用了复制状态机
* 复制状态机更高效
    * 如果操作相对于数据较小
    * 但要正确很难
    * 实验 2/3/4 使用复制状态机
* 在什么层级定义状态复制机？
    * Key/Value 的 put 和 get？
        * 应用层 RSM
        * 通常需要服务端和客户端修改
        * 可以高效；主机只发送高级别的操作给备份机
    * X86 指令？
        * 可能允许我们复制任何 w/o 修改的现有服务器
        * 但是需要更多详细的主备同步
        * 而且我们需要应付中断，DMA，奇怪的 X86 指令
#### 本课论文
* The design of a Practical System for Fault-Tolerant Virtual Machines  
Scales, Nelson, and Venkitachalam, SIGOPS OSR Vol 44, No 4, Dec 2010    
注：课程论文
* 很不凡的系统：
    * 目标：对享有的服务器软件容错
    * 目标：客户端可以感知故障
    * 目标：客户端和服务器软件不需要修改
    *  很有雄心壮志
* 概要
    * 关键词
        * hypervisor == monitor == VMM (virtual machine monitor)
        * 应用和 O/S 是运行在虚拟机内部的“客户”
    * 两台机器，主机和备机
    * 共享磁盘用来持久化存储
        * 共享然后启动新备机更快
    * 主机通过日志通道发送所有输入给备机
* 这个想法为什么能生效？
    * 这是个备份状态机
    * 主机和备机以相同初始化状态启动(内存，磁盘文件)
    * 相同指令，相同输入 -> 相同的执行
        * 在其他条件相同的情况下，主机和备机保持一致
* 我们必须防范哪些差异来源？
    * 很多指令来保证在主机和备机上执行完全一致
        * 只要内存和寄存器一致，我们通过归纳假设
    * 什么时候主机上的执行和备机上的可能不一样？
    * 外界的输入(网络)
    * 从存储服务器读的数据
    * 定时中断
    * 指令不是纯粹的状态函数，例如循环计数器
    * 竞态
* 差异的例子？
    * 它们都听起来像“如果主机宕机了，客户端会从备机中看到不一样的故事”
    * 锁服务器授予客户端 C1 锁，拒绝后续来自 C2 的请求
        * 主备在输入顺序上有更好的商定
        * 否则，主机宕机了，备机告诉客户端 C2 持有锁
    * 锁服务器一分钟只会撤销锁
        * 假设 C1 持有锁，时间几乎用完
        * C2 请求锁
        * 主机可能恰好在计时器中断之前看到 C2 的请求，拒绝
        * 备机可能恰好在计时器中断之后看到 C2 的请求，授权
    * 所以：备机必须看到相同事件，按照相同顺序，在指令流中的同一点
* 例子：定时器中断
    * 目标：主机和备机应该在执行中的同一个点看到中断        
        例如，在同一对执行指令之间
    * 主机：
        * FT 接收定时器中断
        * FT 从 CPU 读取指令码
        * FT 向日志通道发送“定时器在指令 X 中断”
        * FT 向主机发送中断，并恢复它   
        （这依赖于 CPU 的特殊支持来计算指令，在 X 之后中断）
    * 备机：
        * 在自己的定时器硬件上忽略它
        * FT 在备机执行到指令 X 前看到日志条目
        * FT 告诉 CPU 在指令 X 处中断
        * FT模仿定时器中断，恢复备机
* 例子：磁盘/网络输入
    * 主备都请求硬件读入
        * FT 拦截，忽略备机，给主机上的真实硬件
    * 主机：
        * FT 通知硬件直接从内存读取数据放入 FT 的私有“弹跳缓冲”
        * 在某个点硬件从内存读数，然后中断
        * FT 得知中断
        * FT 暂停主机
        * FT 将弹跳缓冲区拷贝存入主机内存
        * FT 模拟一个中断给主机，并恢复它
        * FT 将数据和指令发给备机
    * 备机：
        * FT 从日志流中获取数据和指令
        * FT 通知 CPU 在指令 X 处中断
        * FT 在中断过程中复制数据
    * 为什么需要弹跳缓冲？  
        例如，为什么要在复制数据之前等待主/备份没有执行？
        * 我们想要数据在主备执行的同时数据正好出现在内存
        * 否则它们可能有差异
    * 注意备机必须落后一个事件(一个日志条目)
        * 假设主机在指令 X 后得到一个中断或者输入
        * 如果备机已经执行了 X，那么它就不能正确处理输入
        * 所以备机 FT 不能开始执行直到看到第一条日志条目
            * 然后执行在日志条目中的指令
            * 在重新启动备机前等待下一条日志条目
* 例子：非功能性指令
    * 即使主备拥有相同的内存/寄存器，一些指令仍然会执行不一样   
        例如，读取当前时间或者周期计数，或者处理器序列
    * 主机：
        * FT 将 CPU 设置为中断，如果主机执行了这样一个指令
        * FT 执行指令并记录结果
        * 发送结果和指令给备机
    * 备机：
        * 备机也在尝试执行这个指令时中断
        * FT 提供主机获得的值
* 磁盘/网络输出怎么样？
    * 主备都执行输出指令
    * 主机的 FT 真正执行输出
    * 备机的 FT 丢弃输出
    * 但是：论文中的输出规则(2.2章节)说主机必须在生成输出时通知备机，   
      并且推迟输出直到备机说它已经收到了日志条目
* 为什么需要输出规则？
    * 假设没有输出规则
    * 主机立刻执行输出
    * 假设主机看到了输入 I1 I2 I3，然后执行输出
    * 备机从日志中收到了 I1 和 I2
    * 主机崩溃了而且网络丢失了 I3 的数据包
    * 现在启用了没有执行 I3 的备机
        * 但是一些客户端已经收到了反应主机已经执行了 I3 的输出
        * 因此，客户端如果再次跟服务器交互可能看见异常的状态
    * 因此：主机直到看到备机已经收到到达这个输出的所有输入之后才会执行输出
* 输出规则是个大问题
    * 在所有复制系统中以某种形式存在
    * 对性能严重限制
    * 特定应用程序的领域    
        例如，可能不需要主机等待直到一个只读操作的回复
    * FT 没有应用级知识，必须保守
* 问题：如果主机正好在收到备机确认后，自己输出前崩溃了呢？  
    是不是就意味着输出永远不会生成呢？
    * 回答：
        * 这是主机崩溃，备机接管时发生的情况
        * 备机落后于主机一些日志条目
        * 备机在继续执行日志条目并抑制输出
        * 等最后一条执行完，备机开始执行输出
        * 在我们的例子里，最后的日志条目是 I3
        * 然后在输入 I3 之后，开始发出输出
        * 因此它会输出主机没有输出成功的输出
* 问题：如果主机在发送输出之后崩溃了，备机会不会二次发送输出？
    * 回答：会
        * 对 TCP 没问题，既然接收者忽略重复的序列号
        * 对写入共享磁盘也没问题，既然备机会将相同的数据写入相同的块
    * 切换过程中的重复输出在复制系统很常见
        * 客户端和服务器不总是可用忽略重复      
* 问题：FT 有没有处理网络分区？能不能处理闹裂？     
    例如，如果主备都认为对方宕机了，它们会不会都上线？
    * 回答：
        * 共享磁盘打破了僵局
        * 共享磁盘服务器支持原子性的检查并设置(test-and-set)
        * 只有主备中的一个可以成功的检查并设置
        * 如果一个是活着的，它可以赢得检查并设置而启动
        * 如果都尝试，一个失败，并停住
    * 共享存储是单点失败的
        * 如果共享存储宕机了，服务就宕机了
        * 也许他们想到了一个复制的存储系统
* 性能(表1)
    * FT/Non-FT：优秀
        * 有点慢
    * 日志带宽
        * 直接反应了磁盘读取率和网络输入率
        * mysql 18 Mbit/s 
    * 这些数字对我来说似乎有点低
        * 应用读磁盘最少可以 400 Mbit/s
        * 所以他们的应用不是十分耗费磁盘
* 什么时候 FT 很有吸引力？
    * 关键但低强度的服务，例如名称服务器
    * 那些不容易修改软件的服务
* 复制对于高吞吐的服务怎么样？
    * 人们使用应用级的复制状态机，例如数据库
        * 状态仅仅是数据库，不是所有的内存和磁盘
        * 事件是数据库命令(put 或者 get)，不是数据包或者中断
    * 结论：越细粒度的同步，开销越小
    * GFS 使用应用层的复制，就像 Lab 2
* 总结
    * 主备复制
        * VM-FT：很好的例子
    * 怎么在没有单点失败的情况下处理分区？
        * 下节课
    * 如何获得更好性能
        * 应用级的复制状态机