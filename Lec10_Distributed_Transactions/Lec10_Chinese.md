6.824 2018 Lecture 10: 分布式事务

* 主题：
    * 分布式事务 = 并发控制 + 原子提交
* 什么问题？
    * 很多数据记录，在多台服务器分片，很多客户端
    * 客户端应用操作经常涉及很多读写
        * 银行转账：借记和贷记
        * 文章投票：检查是否已投票，记录投票，增加投票总数
        * 在社交图中安装双向链接
    * 我们想隐藏应用程序编写者的交互和失败
    * 这是传统的数据库问题
        * 今天的材料源于分布式数据库
        * 但这个思想在很多分布式系统中使用
* 示例情况
    * x 和 y 是银行余额 -- 记录在数据库表中
    * x 和 y 在不同服务器上(可能在不同的银行)
    * x 和 y 初始都是 $10
    * 客户端 C1 正在从 x 转 $1 给 y
    * 客户端 C2 正在审计，检查没有钱丢失
    * ```java
      C1:             C2:
      add(x, 1)       tmp1 = get(x)
      add(y, -1)      tmp2 = get(y)
                      print tmp1, tmp2
* 我们希望是什么样子的？
    * x =11
    * y =9
    * C2 输出 10,10 或者 11,9
* 什么可能失败？
    * 不幸的 C1 和 C2 的交错操作
        * C2 整个操作在 C1 的两个操作中间，打印了11,10
        * 服务器或者网络故障
        * 账号 x 或者 y 不存在
* 传统方法：事务
    * 客户端告诉交易系统每个交易的开始结束
    * 系统安排每笔交易是：
        * 原子化：所有写入存在或者没有，即使故障
        * 串行化：结果就好像事务一个一个地执行
        * 持久化：已提交的写入可以在崩溃和重启中不丢失
    * 这些就是 "ACID" 属性
    * 应用基于这些属性
    * 我们对分布式事务感兴趣
        * 数据在多个服务器上分片
* 我们例子的代码可能看起来像这样：
    * T1：
        ```java
       T1:
        begin_transaction()
        add(x, 1)
        add(y, -1)
        end_transaction()
     *  T2:
     ```java
        begin_transaction()
        tmp1 = get(x)
        tmp2 = get(y)
        print tmp1, tmp2
        end_transaction()  
* 如果出现问题，事务可以“终止”
    * 终止不做任何记录修改
    * 交易可能会自愿终止，例如账户不存在
    * 系统可能强制终止，例如打破死锁
    * 某些服务器故障导致终止
    * 应用可能(也可能不会)再次尝试事务
* 分布式事务两大组件
    * 并发控制
    * 原子提交
* 首先，并发控制
    * 并发事务的正确执行
* 传统事务的正确定义是“串行化”
    * 你执行一些并发的产生结果的事务
        * 结果代表新的记录值和输出
    * 结果是串行化的如果：
        * 存在事务的串行执行顺序
        * 产生与实际执行相同的结果
    * (串行代表一次一个 -- 没有并行的执行)
    * (这个定义应该提醒你了线性化)
* 你可以测试一个执行结果是否串行化通过：
    * 查找一个产生相同结果的顺序
    * 对于我们的例子，可能的线性顺序是
        * T1;T2
        * T2;T1
    * 所以正确的(串行化的)结果是：
        * T1; T2 : x=11 y=9 "11,9"
        * T2; T1 : x=11 y=9 "10,10"
    * 两者结果不同；都是对的
    * 没有其他结果 OK 
    * 实现可能并行执行 T1 和 T2
        * 但它必须仍然产生结果就好像在一个串行的顺序中
* 如果 T1 的整个操作在 T2 的两个 get() 之间会怎么样？
    * 结果会串行化吗？
    * T2 会打印 10,9
    * 但是10,9不是两个串行化结果中的一个
* 如果 T2 的整个操作在 T1 的两个 add() 中间呢？
    * T2 会打印 11,10
    * 但是11,10不是两个串行化结果中的一个
* 串行化对编程人员很友好
    * 让他们忽略并发
* 事务的两类并发控制
    * 悲观锁
        * 使用前锁住记录
        * 冲突造成延迟(等待获得锁)
    * 乐观锁
        * 使用记录没有锁
        * 提交检查读/写是否是串行化的
        * 冲突导致退出+重试，但是没有冲突的时候比锁快
        * 称为乐观锁并发控制(OCC)
* 今天：悲观锁并发控制
    * 下周：乐观锁并发控制
* "两阶段锁定"是实现可串行化的一种方法
    * 两阶段锁定
        * 一个事务必须在使用记录前得到记录锁
        * 一个事务必须持有锁知道提交之后或者退出
* 我们例子的两阶段锁定
    * 假设 T1 和 T2 同时开始
    * 事务系统根据需要自动获取锁
    * 所以第一个使用 x 的 T1/T2 会得到锁
    * 其他等待
    * 这禁止了不可串行化的交织
* 细节
    * 每条数据库记录有锁
    * 如果是分布式，锁通常存储在记录的服务器上
    * 执行事务在第一次使用时根据需要获取锁
        * add() 和 get() 隐式获得记录锁
        * end_transaction() 释放所有锁
    * 所有锁是互斥的(对于此讨论，没有读/写锁)
    * 完整的名字是"强要求的两阶段锁定"
    * 与线程锁定有关(例如 GO 的 Mutex)，但是更简单：
        * 明确的开始/结束事务
        * 数据库知道什么被锁了(记录)
        * 退出的可能性(例如解决死锁)
* 为什么持有锁到提交/退出？
    * 为什么不在完成记录后立刻释放
    * 产生问题的例子：
        * 假设 T2 在 get(x) 后释放 x 的锁
        * T1 然后可以在 T2 的 get() 之间执行
        * T2 会打印10，9
        * 哎呀：这不是串行化操作：T1;T2 或者 T2;T1 都不是
    * 产生问题的例子：
        * 假设 T1 写 x，然后释放 x 的锁
        * T2 读取 x 并且打印
        * T1 然后退出
        * 哎呀：T2 使用了一个从没有真正存在的值
        * 我们应该中止 T2，这将是一个"级联中止"； 尴尬
* 2PL能否禁止正确（可串行化）的执行？
    * 是的，例子
        ```java
       T1        T2
        get(x)  
                  get(x)
                  put(x,2)
        put(x,1) 
    * 锁会禁止这种交错
    * 但是结果(x=1)是串行化的(就像 T2;T1)
* 锁会导致死锁，例如
    * ```java
      T1      T2
      get(x)  get(y)
      get(y)  get(x)
    * 系统必须检测(循环？锁超时)并退出事务中的一个
