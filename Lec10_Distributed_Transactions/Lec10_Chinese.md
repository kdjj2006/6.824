6.824 2018 Lecture 10: 分布式事务

* 主题：
    * 分布式事务 = 并发控制 + 原子提交
* 什么问题？
    * 很多数据记录，在多台服务器分片，很多客户端
    * 客户端应用操作经常涉及很多读写
        * 银行转账：借记和贷记
        * 文章投票：检查是否已投票，记录投票，增加投票总数
        * 在社交图中安装双向链接
    * 我们想隐藏应用程序编写者的交互和失败
    * 这是传统的数据库问题
        * 今天的材料源于分布式数据库
        * 但这个思想在很多分布式系统中使用
* 示例情况
    * x 和 y 是银行余额 -- 记录在数据库表中
    * x 和 y 在不同服务器上(可能在不同的银行)
    * x 和 y 初始都是 $10
    * 客户端 C1 正在从 x 转 $1 给 y
    * 客户端 C2 正在审计，检查没有钱丢失
    * ```java
      C1:             C2:
      add(x, 1)       tmp1 = get(x)
      add(y, -1)      tmp2 = get(y)
                      print tmp1, tmp2
* 我们希望是什么样子的？
    * x =11
    * y =9
    * C2 输出 10,10 或者 11,9
* 什么可能失败？
    * 不幸的 C1 和 C2 的交错操作
        * C2 整个操作在 C1 的两个操作中间，打印了11,10
        * 服务器或者网络故障
        * 账号 x 或者 y 不存在
* 传统方法：事务
    * 客户端告诉交易系统每个交易的开始结束
    * 系统安排每笔交易是：
        * 原子化：所有写入存在或者没有，即使故障
        * 串行化：结果就好像事务一个一个地执行
        * 持久化：已提交的写入可以在崩溃和重启中不丢失
    * 这些就是 "ACID" 属性
    * 应用基于这些属性
    * 我们对分布式事务感兴趣
        * 数据在多个服务器上分片
* 我们例子的代码可能看起来像这样：
    * T1：
        ```java
       T1:
        begin_transaction()
        add(x, 1)
        add(y, -1)
        end_transaction()
     *  T2:
     ```java
        begin_transaction()
        tmp1 = get(x)
        tmp2 = get(y)
        print tmp1, tmp2
        end_transaction()  
* 如果出现问题，事务可以“终止”
    * 终止不做任何记录修改
    * 交易可能会自愿终止，例如账户不存在
    * 系统可能强制终止，例如打破死锁
    * 某些服务器故障导致终止
    * 应用可能(也可能不会)再次尝试事务
* 分布式事务两大组件
    * 并发控制
    * 原子提交
* 首先，并发控制
    * 并发事务的正确执行
* 传统事务的正确定义是“串行化”
    * 你执行一些并发的产生结果的事务
        * 结果代表新的记录值和输出
    * 结果是串行化的如果：
        * 存在事务的串行执行顺序
        * 产生与实际执行相同的结果
    * (串行代表一次一个 -- 没有并行的执行)
    * (这个定义应该提醒你了线性化)
* 你可以测试一个执行结果是否串行化通过：
    * 查找一个产生相同结果的顺序
    * 对于我们的例子，可能的线性顺序是
        * T1;T2
        * T2;T1
    * 所以正确的(串行化的)结果是：
        * T1; T2 : x=11 y=9 "11,9"
        * T2; T1 : x=11 y=9 "10,10"
    * 两者结果不同；都是对的
    * 没有其他结果 OK 
    * 实现可能并行执行 T1 和 T2
        * 但它必须仍然产生结果就好像在一个串行的顺序中