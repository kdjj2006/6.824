6.824 2018 Lecture 10: 分布式事务

* 主题：
    * 分布式事务 = 并发控制 + 原子提交
* 什么问题？
    * 很多数据记录，在多台服务器分片，很多客户端
    * 客户端应用操作经常涉及很多读写
        * 银行转账：借记和贷记
        * 文章投票：检查是否已投票，记录投票，增加投票总数
        * 在社交图中安装双向链接
    * 我们想隐藏应用程序编写者的交互和失败
    * 这是传统的数据库问题
        * 今天的材料源于分布式数据库
        * 但这个思想在很多分布式系统中使用
* 示例情况
    * x 和 y 是银行余额 -- 记录在数据库表中
    * x 和 y 在不同服务器上(可能在不同的银行)
    * x 和 y 初始都是 $10
    * 客户端 C1 正在从 x 转 $1 给 y
    * 客户端 C2 正在审计，检查没有钱丢失
    * ```java
      C1:             C2:
      add(x, 1)       tmp1 = get(x)
      add(y, -1)      tmp2 = get(y)
                      print tmp1, tmp2
* 我们希望是什么样子的？
    * x =11
    * y =9
    * C2 输出 10,10 或者 11,9
* 什么可能失败？
    * 不幸的 C1 和 C2 的交错操作
        * C2 整个操作在 C1 的两个操作中间，打印了11,10
        * 服务器或者网络故障
        * 账号 x 或者 y 不存在
* 传统方法：事务
    * 客户端告诉交易系统每个交易的开始结束
    * 系统安排每笔交易是：
        * 原子化：所有写入存在或者没有，即使故障
        * 串行化：结果就好像事务一个一个地执行
        * 持久化：已提交的写入可以在崩溃和重启中不丢失
    * 这些就是 "ACID" 属性
    * 应用基于这些属性
    * 我们对分布式事务感兴趣
        * 数据在多个服务器上分片
* 我们例子的代码可能看起来像这样：
    * T1：
        ```java
       T1:
        begin_transaction()
        add(x, 1)
        add(y, -1)
        end_transaction()
     *  T2:
     ```java
        begin_transaction()
        tmp1 = get(x)
        tmp2 = get(y)
        print tmp1, tmp2
        end_transaction()  
* 如果出现问题，事务可以“终止”
    * 终止不做任何记录修改
    * 交易可能会自愿终止，例如账户不存在
    * 系统可能强制终止，例如打破死锁
    * 某些服务器故障导致终止
    * 应用可能(也可能不会)再次尝试事务
* 分布式事务两大组件
    * 并发控制
    * 原子提交
* 首先，并发控制
    * 并发事务的正确执行
* 传统事务的正确定义是“串行化”
    * 你执行一些并发的产生结果的事务
        * 结果代表新的记录值和输出
    * 结果是串行化的如果：
        * 存在事务的串行执行顺序
        * 产生与实际执行相同的结果
    * (串行代表一次一个 -- 没有并行的执行)
    * (这个定义应该提醒你了线性化)
* 你可以测试一个执行结果是否串行化通过：
    * 查找一个产生相同结果的顺序
    * 对于我们的例子，可能的线性顺序是
        * T1;T2
        * T2;T1
    * 所以正确的(串行化的)结果是：
        * T1; T2 : x=11 y=9 "11,9"
        * T2; T1 : x=11 y=9 "10,10"
    * 两者结果不同；都是对的
    * 没有其他结果 OK 
    * 实现可能并行执行 T1 和 T2
        * 但它必须仍然产生结果就好像在一个串行的顺序中
* 如果 T1 的整个操作在 T2 的两个 get() 之间会怎么样？
    * 结果会串行化吗？
    * T2 会打印 10,9
    * 但是10,9不是两个串行化结果中的一个
* 如果 T2 的整个操作在 T1 的两个 add() 中间呢？
    * T2 会打印 11,10
    * 但是11,10不是两个串行化结果中的一个
* 串行化对编程人员很友好
    * 让他们忽略并发
* 事务的两类并发控制
    * 悲观锁
        * 使用前锁住记录
        * 冲突造成延迟(等待获得锁)
    * 乐观锁
        * 使用记录没有锁
        * 提交检查读/写是否是串行化的
        * 冲突导致退出+重试，但是没有冲突的时候比锁快
        * 称为乐观锁并发控制(OCC)
* 今天：悲观锁并发控制
    * 下周：乐观锁并发控制
### 两阶段锁定
* "两阶段锁定"是实现可串行化的一种方法
    * 两阶段锁定
        * 一个事务必须在使用记录前得到记录锁
        * 一个事务必须持有锁知道提交之后或者退出
* 我们例子的两阶段锁定
    * 假设 T1 和 T2 同时开始
    * 事务系统根据需要自动获取锁
    * 所以第一个使用 x 的 T1/T2 会得到锁
    * 其他等待
    * 这禁止了不可串行化的交织
* 细节
    * 每条数据库记录有锁
    * 如果是分布式，锁通常存储在记录的服务器上
    * 执行事务在第一次使用时根据需要获取锁
        * add() 和 get() 隐式获得记录锁
        * end_transaction() 释放所有锁
    * 所有锁是互斥的(对于此讨论，没有读/写锁)
    * 完整的名字是"强要求的两阶段锁定"
    * 与线程锁定有关(例如 GO 的 Mutex)，但是更简单：
        * 明确的开始/结束事务
        * 数据库知道什么被锁了(记录)
        * 退出的可能性(例如解决死锁)
* 为什么持有锁到提交/退出？
    * 为什么不在完成记录后立刻释放
    * 产生问题的例子：
        * 假设 T2 在 get(x) 后释放 x 的锁
        * T1 然后可以在 T2 的 get() 之间执行
        * T2 会打印10，9
        * 哎呀：这不是串行化操作：T1;T2 或者 T2;T1 都不是
    * 产生问题的例子：
        * 假设 T1 写 x，然后释放 x 的锁
        * T2 读取 x 并且打印
        * T1 然后退出
        * 哎呀：T2 使用了一个从没有真正存在的值
        * 我们应该中止 T2，这将是一个"级联中止"； 尴尬
* 2PL能否禁止正确（可串行化）的执行？
    * 是的，例子
        ```java
       T1        T2
        get(x)  
                  get(x)
                  put(x,2)
        put(x,1) 
    * 锁会禁止这种交错
    * 但是结果(x=1)是串行化的(就像 T2;T1)
* 锁会导致死锁，例如
    * ```java
      T1      T2
      get(x)  get(y)
      get(y)  get(x)
    * 系统必须检测(循环？锁超时)并退出事务中的一个
* 问题：描述了两阶段锁定比简单锁定产生更高性能的情况。简单锁：在任何使用前锁定每个记录，在终止/提交后释放

### 下一个主题：分布式事务与失败
* 分布式事务如何应对失败？
    * 假设，对于我们的例子，x 和 y 位于不同的"工作"服务器上
    * 假设，x 的服务器加1，当 y 的在做减法前崩溃了
    * 或者 x 的服务器加1，但是 y 的服务器发现账号不存在？
    * 或者 x 和 y 各做各的，但是不能确定对方是否完成了？
* 我们希望"原子化提交"
    * 一堆计算机正在合作完成某项任务 
    * 每台计算机有不同的角色
    * 希望确保原子性：全部执行或者都不执行
    * 挑战：故障，性能
* 我们会开发一个叫"两阶段提交"的协议
    * 由分布式数据库用于多服务器事务
    * 我们假设数据库也是锁定的
* 没有故障的两阶段提交
    * 该事务由事务协调器驱动
    * [时间图：TC,A,B]
    * TC 发送 put(),get(), RPCs 给 A，B
        * 修改是暂时的，只有在提交时才能安装
    * TC 发送 transaction_end()
    * TC 发送 PREPARE(准备) 消息给 A 和 B
    * 如果 A(或者 B) 愿意提交
        * 回复 YES
        * 然后 A/B 进入"准备好"状态
    * 否则回复 NO
    * 如果都说 YES，TC 发送 COMMIT(提交)消息
    * 如果有一个人说 NO，TC 发送 ABORT(中止)消息
    * A/B 提交如果他们收到一个 COMMIT(提交)消息
        * 他们将暂时的记录写入真实数据库
        * 释放他们记录上的事务的锁
* 为什么到目前为止是正确的？
    * 只有都同意才能提交
* 如果 B 崩溃并重启了会怎样？
    * 如果 B 在崩溃钱发送了 YES，B 必须记住
    * 因为 A 可能已经收到了一个 COMMIT(提交)消息并且已经提交了
    * 所以 B 即使在重启后必须有能力提交(或者不提交)
* 因此下属必须写持久（磁盘上）状态：
    * B 必须在回复 YES 之前在磁盘上记录，包括修改的数据
    * 如果 B 重启了，磁盘上为 YES 但是没有提交，B 必须询问  TC，或者等待 TC 重发
    * 同时，B 必须继续持有事务的锁
    * 如果 TC 说提交，B 将修改数据拷贝为真实数据
* 如果 TC 崩溃并重启了怎么样？
    * 如果 TC 可能已经在崩溃前发送了 COMMIT(提交), TC 必须记住
        * 因为一个工作者(A/B)可能已经提交了
    * 如果任何人询问则重复发送(如果 A/B 没有收到消息)
    * 因此 TC 必须在发送 COMMIT(提交) 消息前将 COMMIT(提交)写入磁盘
* 如果 TC 没有从 A/B 收到 YES/NO 会怎么样？
    * 可能 B 崩溃了并且没有恢复，可能网络问题
    * TC 可以超时并中止(既然还没有发送任何 COMMIT(提交)消息)
    * 很好：允许服务器释放锁
* 如果 B 在等待 TC 的 PREPARE(准备)消息的时候超时或者崩溃了会怎么样？
    * B 还没有回复 PREPARE(准备)，所以 TC 不能决定提交
    * B 单方面中止，释放锁
    * 对未来的 PREPARE(准备)回复 NO
* 如果 B 对 PREPARE(准备)回复了 YES，但是没有收到 COMMIT(提交)或者 ABORT(中止)会怎么样？
    * B 可以单方面决定中止吗？
        * 不可以，TC 可能已经从 A/B 都收到了 YES
        * 并且 TC 发送了 COMMIT(提交)给A，但在发送给 B 之前崩溃了
        * A 会提交，B 会中止：不正确
    * B 不能单方面提交
        * A 可能选择了 NO
    * 所以如果 B 选择了 YES，必须阻塞：等待 TC 的决定
* 两阶段提交透视
    * 当事务使用多个分片上的数据时，在分片 DB 中使用
    * 但它有个坏名声：
        * 慢：多轮消息
        * 慢：磁盘写入
        * 在准备/提交消息交换中持有锁，阻塞其他操作
        * TC崩溃可导致无限制阻塞，一直持有锁
    * 因此通常仅在单个小域中使用
        * 例如不在银行间，不在航班间，不在大范围
    * 更快的分布式交易是一个活跃的研究领域：
        * 更低的消息和持久化成本
        * 可以用较少的工作处理的特殊情况
        * 广域事务
        * 应用程序的一致性较低，负担较重
* Raft 和 两阶段提交解决不同的问题
    * 使用 Raft 通过副本来获得高可用性
        * 当一些服务器宕机了还能继续工作
        * 服务器都做一样的事情
    * 使用两阶段提交当下属做不同事情
        * 并且"所有的"他们都要完成自己的工作
    * 2PC(两阶段提交)对高可用没有帮助
        * 因为所有服务器要一起来完成某件事情
    * Raft 不保证所有服务器都做了某些事
        * 因为只需要大部分服务器活着
* 如果你要高可用和原子化提交呢？
    * 这里是一个方案
    * 每个服务器应该是一个 Raft-replicated 服务
    * TC 也应该是 Raft-replicated
    * 在副本服务器之间运行两阶段提交
    * 然后你就可以容错并且仍在运行
    * 你会在实验4中构造像这样的来转移分片
    * 下次的 FaRM 有一种不同的方法