6.824 2018 Lecture 6: Raft (2)

* 回顾下大局：
    * key/value 服务器作为例子，就像实验3中的那样
    * 目标：与单个非复制服务器相同的客户端可见行为
    * 目标：可用即使少数机器故障/失联
    * 注意网络分区和脑裂
    * “状态机”，应用，服务

* 一些提醒
    * 领导者在大多数回复了 AppendEntries 之后提交/执行
    * 领导者通知追随者提交，哪些执行(== 发送 applyCh )
    * 为什么只等待大多数？为什么不等所有机器？
        * 可用性要求即使小部分崩溃了仍然执行
    * 为什么大多数就足够了？
        * 任何两个大多数有重叠
        * 所以历届领导者的大多数至少在一个点重叠
        * 所以下一个领导者确保可以看见前面领导者提交的任何日志条目
    * 是所有机器的大多数(死的和存活的)，不只是存活机器的大多数

### 主题：Raft 日志 (实验 2B)
* 只要领导者启动了
    * 客户端只与领导者交互
    * 客户端不受追随者行为的影响
* 事情只有在改变领导者的时候才有趣
    * 例如，在旧领导者故障之后
    * 如何在客户端看不到异常的情况下改变领导者
        * 旧读，重复操作，丢失操作，不一样的顺序
* 我们希望确保什么？
    * 如果任何服务器执行在一个日志条目中的给定命令
        * 那么没有服务器执行那个日志条目的其他操作(图3的状态机安全性)
    * 为什么？如果服务器对操作不一致，那么 a 改变领导者可能会改变客户可见状态，这违反了我们模仿单个服务器的目标
    * 例如
        >   S1: put(k1,v1) | put(k1,v2) | ...   
            S2: put(k1,v1) | put(k2,x)  | ...
            
        不允许同时执行他妈的第二个日志条目
* 崩溃后日志如何不一样？
    * 一个领导者在给所以人发送最后的 AppendEntries 之前崩溃了
        > S1: 3     
          S2: 3 3   
          S3: 3 3   
    * 更糟糕的：日志可能在相同的条目中有不同的命令，例如在一系列的领导者崩溃之后
         >  10 11 12 13  <- log entry #    
             S1:  3     
             S2:  3  3  4   
             S3:  3  3  5