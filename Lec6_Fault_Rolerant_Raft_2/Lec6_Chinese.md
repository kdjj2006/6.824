6.824 2018 Lecture 6: Raft (2)

* 回顾下大局：
    * key/value 服务器作为例子，就像实验3中的那样
    * 目标：与单个非复制服务器相同的客户端可见行为
    * 目标：可用即使少数机器故障/失联
    * 注意网络分区和脑裂
    * “状态机”，应用，服务

* 一些提醒
    * 领导者在大多数回复了 AppendEntries 之后提交/执行
    * 领导者通知追随者提交，哪些执行(== 发送 applyCh )
    * 为什么只等待大多数？为什么不等所有机器？
        * 可用性要求即使小部分崩溃了仍然执行
    * 为什么大多数就足够了？
        * 任何两个大多数有重叠
        * 所以历届领导者的大多数至少在一个点重叠
        * 所以下一个领导者确保可以看见前面领导者提交的任何日志条目
    * 是所有机器的大多数(死的和存活的)，不只是存活机器的大多数

### 主题：Raft 日志 (实验 2B)
* 只要领导者启动了
    * 客户端只与领导者交互
    * 客户端不受追随者行为的影响
* 事情只有在改变领导者的时候才有趣
    * 例如，在旧领导者故障之后
    * 如何在客户端看不到异常的情况下改变领导者
        * 旧读，重复操作，丢失操作，不一样的顺序
* 我们希望确保什么？
    * 如果任何服务器执行在一个日志条目中的给定命令
        * 那么没有服务器执行那个日志条目的其他操作(图3的状态机安全性)
    * 为什么？如果服务器对操作不一致，那么 a 改变领导者可能会改变客户可见状态，这违反了我们模仿单个服务器的目标
    * 例如
        >   S1: put(k1,v1) | put(k1,v2) | ...   
            S2: put(k1,v1) | put(k2,x)  | ...
            
        不允许同时执行他妈的第二个日志条目
* 崩溃后日志怎么不一样？
    * 一个领导者在给所以人发送最后的 AppendEntries 之前崩溃了
        > S1: 3     
          S2: 3 3   
          S3: 3 3   
    * 更糟糕的：日志可能在相同的条目中有不同的命令，例如在一系列的领导者崩溃之后
         >  10 11 12 13  <- log entry #    
             S1:  3     
             S2:  3  3  4   
             S3:  3  3  5
* Raft 通过追随者采用新领导者的日志来强制一致
    * 例子：
        * S3 在任期6中被选为新领导者
        * S3 发送一个包含条目13的 AppendEntries 
            > prevLogIndex=12
              prevLogTerm=5
        * S2 回复 false(AppendEntries 第二步)
        * S3 将 nextIndex[S2] 降为12
        * S3 发送 AppendEntries 条目 12+13, prevLogIndex=11, prevLogTerm=3
        * S2 删除自己的条目12(AppendEntries 第三步)
        * 对于 S1 类似，但是必须再往回退一步
* 回滚的结果
    * 每个活着的追随者删除了自己日志尾部与领导者不一样的部分
    * 然后每个活着的追随者接受领导者在这个点之后的条目
    * 现在追随者和领导者的日志一样
* 问题：为什么把 S2 的 index=12,term=4 的条目忘记了是可以的？
* 领导者能不能回滚上一个任期末尾已提交的条目？
    * 例如，一个已提交的日志条目能不能从新领导者的日志中丢失？
    * 因此：Raft 需要确保新的领导者拥有所有已提交的日志条目
* 为什么不选拥有最长日志的服务器当领导者？
    * 例子
    > S1: 5 6 7     
      S2: 5 8     
      S3: 5 8     
    * 首先，这种情况能不能发生？怎么发生？
        * S1 是任期6的领导者，崩溃重启，是任期7的领导者，两次都在仅仅追加了自己的日志后崩溃并且保持宕机
        * 下个任期是8，因为 S2/S3 中至少有一个在投票时得知了7
        * S2 是任期8的领导者，只有 S2和S3 活着，然后崩溃了
    * 所有机器重启
    * 谁会是下个领导者？
        * S1 有最长日志，但是条目8本可以提交
        * 所以新领导者只能是 S2 和 S3 中的一个
        * 规则不能是简单的"最长日志"