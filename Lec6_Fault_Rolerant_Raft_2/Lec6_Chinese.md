6.824 2018 Lecture 6: Raft (2)

* 回顾下大局：
    * key/value 服务器作为例子，就像实验3中的那样
    * 目标：与单个非复制服务器相同的客户端可见行为
    * 目标：可用即使少数机器故障/失联
    * 注意网络分区和脑裂
    * “状态机”，应用，服务

* 一些提醒
    * 领导者在大多数回复了 AppendEntries 之后提交/执行
    * 领导者通知追随者提交，哪些执行(== 发送 applyCh )
    * 为什么只等待大多数？为什么不等所有机器？
        * 可用性要求即使小部分崩溃了仍然执行
    * 为什么大多数就足够了？
        * 任何两个大多数有重叠
        * 所以历届领导者的大多数至少在一个点重叠
        * 所以下一个领导者确保可以看见前面领导者提交的任何日志条目
    * 是所有机器的大多数(死的和存活的)，不只是存活机器的大多数

### 主题：Raft 日志 (实验 2B)
* 只要领导者启动了
    * 客户端只与领导者交互
    * 客户端不受追随者行为的影响
* 事情只有在改变领导者的时候才有趣
    * 例如，在旧领导者故障之后
    * 如何在客户端看不到异常的情况下改变领导者
        * 旧读，重复操作，丢失操作，不一样的顺序
* 我们希望确保什么？
    * 如果任何服务器执行在一个日志条目中的给定命令
        * 那么没有服务器执行那个日志条目的其他操作(图3的状态机安全性)
    * 为什么？如果服务器对操作不一致，那么 a 改变领导者可能会改变客户可见状态，这违反了我们模仿单个服务器的目标
    * 例如
        >   S1: put(k1,v1) | put(k1,v2) | ...   
            S2: put(k1,v1) | put(k2,x)  | ...
            
        不允许同时执行他妈的第二个日志条目
* 崩溃后日志怎么不一样？
    * 一个领导者在给所以人发送最后的 AppendEntries 之前崩溃了
        > S1: 3     
          S2: 3 3   
          S3: 3 3   
    * 更糟糕的：日志可能在相同的条目中有不同的命令，例如在一系列的领导者崩溃之后
         >  10 11 12 13  <- log entry #    
             S1:  3     
             S2:  3  3  4   
             S3:  3  3  5
* Raft 通过追随者采用新领导者的日志来强制一致
    * 例子：
        * S3 在任期6中被选为新领导者
        * S3 发送一个包含条目13的 AppendEntries 
            > prevLogIndex=12
              prevLogTerm=5
        * S2 回复 false(AppendEntries 第二步)
        * S3 将 nextIndex[S2] 降为12
        * S3 发送 AppendEntries 条目 12+13, prevLogIndex=11, prevLogTerm=3
        * S2 删除自己的条目12(AppendEntries 第三步)
        * 对于 S1 类似，但是必须再往回退一步
* 回滚的结果
    * 每个活着的追随者删除了自己日志尾部与领导者不一样的部分
    * 然后每个活着的追随者接受领导者在这个点之后的条目
    * 现在追随者和领导者的日志一样
* 问题：为什么把 S2 的 index=12,term=4 的条目忘记了是可以的？
* 领导者能不能回滚上一个任期末尾已提交的条目？
    * 例如，一个已提交的日志条目能不能从新领导者的日志中丢失？
    * 因此：Raft 需要确保新的领导者拥有所有已提交的日志条目
* 为什么不选拥有最长日志的服务器当领导者？
    * 例子
    > S1: 5 6 7     
      S2: 5 8     
      S3: 5 8     
    * 首先，这种情况能不能发生？怎么发生？
        * S1 是任期6的领导者，崩溃重启，是任期7的领导者，两次都在仅仅追加了自己的日志后崩溃并且保持宕机
        * 下个任期是8，因为 S2/S3 中至少有一个在投票时得知了7
        * S2 是任期8的领导者，只有 S2和S3 活着，然后崩溃了
    * 所有机器重启
    * 谁会是下个领导者？
        * S1 有最长日志，但是条目8本可以提交
        * 所以新领导者只能是 S2 和 S3 中的一个
        * 规则不能是简单的“最长日志”
* 5.4.1 章节结束的时候解释了“选举限制”
    * RequestVote处理程序仅对“至少一样新”的候选人进行投票：
        * 候选人在上次的日志条目中有更好的任期号，或者
        * 候选人有相同的上次任期号和一样或更长的日志
    * 因此：
        * S2 和 S3 不会给 S1 投票
        * S2 和 S3 会互相投票
    * 所以只有 S2 或者 S3 可以是领导者，会强制 S1 丢弃6,7
        * 既然6,7不在多数上 -> 没有提交 -> 没有回复发给客户 
            -> 客户端会重发6,7中的命令
* 关键点：
    * "至少一样新"规则确保了新领导者的日志包括了所有可能已经提交的条目
    * 所以新领导者不会回滚任何提交操作
* 问题(来自上一课)
    * 图7，顶层服务器死了，可以选举哪个？
* 基于在图7中谁是选举的领导者，不同的条目
    * 会最终提交或丢弃
    * c 的6和 d 的7，7可能会被丢弃或者提交
    * 一些会一直保持提交了：111445566
* 如何快速回滚
    * 图2设计为每个 RPC 备份一个条目 --  慢
    * 实验测试者可能需要更快的回滚
    * 论文在5.3章节末尾列出了一个方案
        * 没有细节，这是我的猜测，可能有更好的方案
            >
                S1: 4 5 5      4 4 4      4       
                S2: 4 6 6  or  4 6 6  or  4 6 6       
                S3: 4 6 6      4 6 6      4 6 6       
        * S3 是任期6的领导者，S1 活过来了
        * 如果追随者拒绝了 AppendEntries，回复中包含这些：
            * 在冲突的条目中含有追随者任期
            * 追随者在那个任期中第一个条目的索引
        * 如果领导者有和追随者冲突任期的日志条目：
            * 将 nextIndex [i] 移回到领导者的冲突任期的最后一个条目
        * 或者：
            * 将 nextIndex [i] 移回到追随者的冲突任期的第一个条目