6.824 2018 Lecture 6: Raft (2)

* 回顾下大局：
    * key/value 服务器作为例子，就像实验3中的那样
    * 目标：与单个非复制服务器相同的客户端可见行为
    * 目标：可用即使少数机器故障/失联
    * 注意网络分区和脑裂
    * “状态机”，应用，服务

* 一些提醒
    * 领导者在大多数回复了 AppendEntries 之后提交/执行
    * 领导者通知追随者提交，哪些执行(== 发送 applyCh )
    * 为什么只等待大多数？为什么不等所有机器？
        * 可用性要求即使小部分崩溃了仍然执行
    * 为什么大多数就足够了？
        * 任何两个大多数有重叠
        * 所以历届领导者的大多数至少在一个点重叠
        * 所以下一个领导者确保可以看见前面领导者提交的任何日志条目
    * 是所有机器的大多数(死的和存活的)，不只是存活机器的大多数

### 主题：Raft 日志 (实验 2B)
* 只要领导者启动了
    * 客户端只与领导者交互
    * 客户端不受追随者行为的影响
* 事情只有在改变领导者的时候才有趣
    * 例如，在旧领导者故障之后
    * 如何在客户端看不到异常的情况下改变领导者
        * 旧读，重复操作，丢失操作，不一样的顺序
* 我们希望确保什么？
    * 如果任何服务器执行在一个日志条目中的给定命令
        * 那么没有服务器执行那个日志条目的其他操作(图3的状态机安全性)
    * 为什么？如果服务器对操作不一致，那么 a 改变领导者可能会改变客户可见状态，这违反了我们模仿单个服务器的目标
    * 例如
        >   S1: put(k1,v1) | put(k1,v2) | ...   
            S2: put(k1,v1) | put(k2,x)  | ...
            
        不允许同时执行他妈的第二个日志条目
* 崩溃后日志怎么不一样？
    * 一个领导者在给所以人发送最后的 AppendEntries 之前崩溃了
        > S1: 3     
          S2: 3 3   
          S3: 3 3   
    * 更糟糕的：日志可能在相同的条目中有不同的命令，例如在一系列的领导者崩溃之后
         >  10 11 12 13  <- log entry #    
             S1:  3     
             S2:  3  3  4   
             S3:  3  3  5
* Raft 通过追随者采用新领导者的日志来强制一致
    * 例子：
        * S3 在任期6中被选为新领导者
        * S3 发送一个包含条目13的 AppendEntries 
            > prevLogIndex=12
              prevLogTerm=5
        * S2 回复 false(AppendEntries 第二步)
        * S3 将 nextIndex[S2] 降为12
        * S3 发送 AppendEntries 条目 12+13, prevLogIndex=11, prevLogTerm=3
        * S2 删除自己的条目12(AppendEntries 第三步)
        * 对于 S1 类似，但是必须再往回退一步
* 回滚的结果
    * 每个活着的追随者删除了自己日志尾部与领导者不一样的部分
    * 然后每个活着的追随者接受领导者在这个点之后的条目
    * 现在追随者和领导者的日志一样
* 问题：为什么把 S2 的 index=12,term=4 的条目忘记了是可以的？
* 领导者能不能回滚上一个任期末尾已提交的条目？
    * 例如，一个已提交的日志条目能不能从新领导者的日志中丢失？
    * 因此：Raft 需要确保新的领导者拥有所有已提交的日志条目
* 为什么不选拥有最长日志的服务器当领导者？
    * 例子
    > S1: 5 6 7     
      S2: 5 8     
      S3: 5 8     
    * 首先，这种情况能不能发生？怎么发生？
        * S1 是任期6的领导者，崩溃重启，是任期7的领导者，两次都在仅仅追加了自己的日志后崩溃并且保持宕机
        * 下个任期是8，因为 S2/S3 中至少有一个在投票时得知了7
        * S2 是任期8的领导者，只有 S2和S3 活着，然后崩溃了
    * 所有机器重启
    * 谁会是下个领导者？
        * S1 有最长日志，但是条目8本可以提交
        * 所以新领导者只能是 S2 和 S3 中的一个
        * 规则不能是简单的“最长日志”
* 5.4.1 章节结束的时候解释了“选举限制”
    * RequestVote处理程序仅对“至少一样新”的候选人进行投票：
        * 候选人在上次的日志条目中有更好的任期号，或者
        * 候选人有相同的上次任期号和一样或更长的日志
    * 因此：
        * S2 和 S3 不会给 S1 投票
        * S2 和 S3 会互相投票
    * 所以只有 S2 或者 S3 可以是领导者，会强制 S1 丢弃6,7
        * 既然6,7不在多数上 -> 没有提交 -> 没有回复发给客户 
            -> 客户端会重发6,7中的命令
* 关键点：
    * "至少一样新"规则确保了新领导者的日志包括了所有可能已经提交的条目
    * 所以新领导者不会回滚任何提交操作
* 问题(来自上一课)
    * 图7，顶层服务器死了，可以选举哪个？
* 基于在图7中谁是选举的领导者，不同的条目
    * 会最终提交或丢弃
    * c 的6和 d 的7，7可能会被丢弃或者提交
    * 一些会一直保持提交了：111445566
* 如何快速回滚
    * 图2设计为每个 RPC 备份一个条目 --  慢
    * 实验测试者可能需要更快的回滚
    * 论文在5.3章节末尾列出了一个方案
        * 没有细节，这是我的猜测，可能有更好的方案
            >
                S1: 4 5 5      4 4 4      4       
                S2: 4 6 6  or  4 6 6  or  4 6 6       
                S3: 4 6 6      4 6 6      4 6 6       
        * S3 是任期6的领导者，S1 活过来了
        * 如果追随者拒绝了 AppendEntries，回复中包含这些：
            * 在冲突的条目中含有追随者任期
            * 追随者在那个任期中第一个条目的索引
        * 如果领导者有和追随者冲突任期的日志条目：
            * 将 nextIndex [i] 移回到领导者的冲突任期的最后一个条目
        * 或者：
            * 将 nextIndex [i] 移回到追随者的冲突任期的第一个条目
### 主题：持久化(实验 2C )
* 我们希望一个服务器崩溃之后发生什么？
    * Raft 可以在丢失一个服务器的情况下继续
        * 但是我们要马上修复来防止低于大多数
    * 两种策略：
        * 用一个新的(空的)服务器代替
            * 需要传递日志(或者快照)给新服务器(慢)
            * 我们必须支持这个，如果故障是永久的
        * 或者重启崩溃的服务器，重新用完整状态加入，赶上
            * 需要在崩溃期间持续存在的状态
            * 我们必须支持，由于可能同时断电
    * 让我们讨论第二种策略--持久化
* 如果一台服务器崩溃并重启，Raft 需要记住什么？
    * 图2列出了“持久化状态”
        *  log[], currentTerm, votedFor
    * 一台 Raft 服务器只有这些是完整的才能在重启后才能重新加入
    * 因此它必须保存这些在非易失性的存储中
        * 非易失性 = 磁盘，SSD，电池供电的RAM
        * 在每个改变之后保存
        * 在发送任何 RPC 或者 RPC 回复之前
    * 为什么需要 log[]？
        * 如果一台服务器在领导者用来提交日志条目的大多数中
            * 必须记住条目即使重启，因此任何故障的领导者可以保证能看到已提交的日志条目
    * 为什么需要 votedFor？
        * 防止一个客户端为一个候选人投票，然后重启
            * 然后为一个在相同(更旧)任期中的不同的候选人投票
        * 可能导致一个任期中两个领导者
    * 为什么需要 currentTerm？
        * 确保任期数值只增不减
        * 检测过时的领导者和候选人的 RPC
* 一些 Raft 状态是不稳定的
    * commitIndex, lastApplied, next/matchIndex[]
    * Raft 的算法从初始化的值重新构建
* 持久化经常是性能的瓶颈
    * 一块磁盘写入花费 10 ms, SSD 写入花费 0.1 ms
    * 所以持久化限制在 100-10,000 次/秒     
        (另外潜在的瓶颈就是 RPC，在 LAN 中花费远小于 1ms)
    * 很多技巧来应对持久化的缓慢：
        * 每个磁盘写入批处理批量的新日志条目
        * 持久化进电池供电的 RAM，而不是磁盘
* 服务(例如 k/v 服务器)如何在崩溃重启后恢复状态？
    * 简单方法：以空状态启动，重放 Raft 的整个持久化日志
        * lastApplied 是不稳定的并且以 0 启动，所以你不需要额外的代码
    * 但是重放对一个已长期存在的系统来说太慢
    * 更快：使用 Raft 快照并仅仅重放日志尾部
### 主题：日志压缩和快照(实验 3B)
* 问题：
    * 日志会变的很大 -- 比状态机的状态大很多
    * 会花费很长时间去重启时重放或者发送给一台新服务器
* 幸运的：
    * 一台服务器不同时需要完整的日志和服务状态
        * 已执行的日志部分在状态中被捕获
        * 客户端只看到状态，而不是日志
    * 服务状态通常小很多，所以让我们只保持这点
* 什么限制了服务器如何丢弃日志条目？
    * 不能忘记未提交条目 -- 可能是领导者的大多数的一部分
    * 不能忘记未执行条目 -- 还未反应在状态中
    * 已执行的条目可能需要来让其他服务器保持最新状态
* 解决方案：服务定期创建持久的“快照”
    * 执行特定日志条目时整个状态机状态的副本，例如 k/v table
    * 服务将快照写入持久化存储(磁盘)
    * 服务通知 Raft 通过一些日志索引进行了快照
    * Raft 丢弃此索引前的日志
    * 一个服务器可以在任何时刻新建快照和丢弃前面的日志，例如当日志增长到太长
* 快照和日志的关系
    * 快照只反应已执行的日志条目
        * 因此只是已提交的条目
    * 所以服务器只会丢弃已提交的日志前缀
        * 任何未知的事情都将留在日志中
* 所以一个服务器的磁盘状态包括：
    * 服务直到某条日志条目的快照
    * Raft 的持久化日志包含以下日志条目
    * 该组合相当于完整日志
* 崩溃和重启过程中会发生什么？
    * 服务器从磁盘读取快照
    * Raft 从磁盘读取持久化日志
        * 给服务发送已提交但不在快照中的日志条目